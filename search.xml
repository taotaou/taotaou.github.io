<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Local模式下RDD编程</title>
      <link href="2021/08/20/rdd-code/"/>
      <url>2021/08/20/rdd-code/</url>
      
        <content type="html"><![CDATA[<h2 id="1-RDD编程"><a href="#1-RDD编程" class="headerlink" title="1 RDD编程"></a>1 RDD编程</h2><h3 id="1-1编程模型"><a href="#1-1编程模型" class="headerlink" title="1.1编程模型"></a>1.1编程模型</h3><p>在Spark中，RDD被表示为对象，通过对象上的方法调用来对RDD进行转换。<br>经过一系列的<b>transformations定义RDD之后，就可以调用actions触发RDD的计算</b>，<br>action可以是向应用程序返回结果(count, collect等)， 或者是向存储系统保存数据(saveAsTextFile等)。<br>在Spark中，<b>只有遇到action，才会执行RDD的计算(即延迟计算)</b>，这样在运行时可以通过管道的方式输多个转换。<br><br/><br><img src="https://taogege.xyz/medias/pic_data/09/02_01.png"/></p><h3 id="1-2-RDD创建"><a href="#1-2-RDD创建" class="headerlink" title="1.2 RDD创建"></a>1.2 RDD创建</h3><p><b>在spark中RDD创建可以分为三种：从集合中创建RDD、从外部存储创建RDD、从其他RDD创建。</b></p><h3 id="1-2-1-Idea环境搭建"><a href="#1-2-1-Idea环境搭建" class="headerlink" title="1.2.1 Idea环境搭建"></a>1.2.1 Idea环境搭建</h3><p>1.创建maven工程。<br/><br>2.在pom文件中添加</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span>dependencies<span class="token operator">></span>    <span class="token operator">&lt;</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org.apache.spark<span class="token operator">&lt;</span>/groupId<span class="token operator">></span>        <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spark-core_2.12<span class="token operator">&lt;</span>/artifactId<span class="token operator">></span>        <span class="token operator">&lt;</span>version<span class="token operator">></span>3.0.0<span class="token operator">&lt;</span>/version<span class="token operator">></span>    <span class="token operator">&lt;</span>/dependency<span class="token operator">></span><span class="token operator">&lt;</span>/dependencies<span class="token operator">></span><span class="token operator">&lt;</span>build<span class="token operator">></span>    <span class="token operator">&lt;</span>finalName<span class="token operator">></span>SparkCoreTest<span class="token operator">&lt;</span>/finalName<span class="token operator">></span>    <span class="token operator">&lt;</span>plugins<span class="token operator">></span>        <span class="token operator">&lt;</span>plugin<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>net.alchim31.maven<span class="token operator">&lt;</span>/groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>scala-maven-plugin<span class="token operator">&lt;</span>/artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span>3.4.6<span class="token operator">&lt;</span>/version<span class="token operator">></span>            <span class="token operator">&lt;</span>executions<span class="token operator">></span>                <span class="token operator">&lt;</span>execution<span class="token operator">></span>                    <span class="token operator">&lt;</span>goals<span class="token operator">></span>                        <span class="token operator">&lt;</span>goal<span class="token operator">></span>compile<span class="token operator">&lt;</span>/goal<span class="token operator">></span>                        <span class="token operator">&lt;</span>goal<span class="token operator">></span>testCompile<span class="token operator">&lt;</span>/goal<span class="token operator">></span>                    <span class="token operator">&lt;</span>/goals<span class="token operator">></span>                <span class="token operator">&lt;</span>/execution<span class="token operator">></span>            <span class="token operator">&lt;</span>/executions<span class="token operator">></span>        <span class="token operator">&lt;</span>/plugin<span class="token operator">></span>    <span class="token operator">&lt;</span>/plugins<span class="token operator">></span><span class="token operator">&lt;</span>/build<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.搭建Scala框架支持</p><h3 id="1-2-2-从集合中创建"><a href="#1-2-2-从集合中创建" class="headerlink" title="1.2.2 从集合中创建"></a>1.2.2 从集合中创建</h3><p>1：从集合中创建RDD，Spark主要提供了两种函数：parallelize和makeRDD<br>parallelize</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> org.apache.spark.rdd.RDD<span class="token function">import</span> org.apache.spark.<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;SparkConf, SparkContext&amp;#125;</span>object createrdd01_array <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    def main<span class="token punctuation">(</span>args: Array<span class="token punctuation">[</span>String<span class="token punctuation">]</span><span class="token punctuation">)</span>: Unit <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        //1.创建SparkConf并设置App名称        val conf: SparkConf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc: SparkContext <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3.使用parallelize<span class="token punctuation">(</span><span class="token punctuation">)</span>创建rdd        val rdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> sc.parallelize<span class="token punctuation">(</span>Array<span class="token punctuation">(</span>1, 2, 3, 4, 5, 6, 7, 8<span class="token punctuation">))</span>        rdd.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        println<span class="token punctuation">(</span><span class="token string">"分区数："</span> + rdd.partitions.size<span class="token punctuation">)</span>        //4.使用makeRDD<span class="token punctuation">(</span><span class="token punctuation">)</span>创建rdd        val rdd1: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> sc.makeRDD<span class="token punctuation">(</span>Array<span class="token punctuation">(</span>1, 2, 3, 4, 5, 6, 7, 8<span class="token punctuation">))</span>        rdd1.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        println<span class="token punctuation">(</span><span class="token string">"分区数："</span> + rdd1.partitions.size<span class="token punctuation">)</span>        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-从外部存储系统的数据集创建"><a href="#1-2-3-从外部存储系统的数据集创建" class="headerlink" title="1.2.3 从外部存储系统的数据集创建"></a>1.2.3 从外部存储系统的数据集创建</h3><p>由外部存储系统的数据集创建RDD包括：<b>本地的文件系统，所有hadoop支持的数据集，如HDFS，HBASE等。</b></p><p>1.数据准备<br><br>在项目目录下创建inout文件用来放模拟外部存储的数据<br><br>2.创建RDD</p><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf: SparkConf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc: SparkContext <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3.读取文件。如果是集群路径：hdfs://hadoop102:9000/input        val lineWordRdd: RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token operator">=</span> sc.textFile<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span>        //4.打印        lineWordRdd.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        //5.关闭        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-Transformation转换算子-重点"><a href="#1-3-Transformation转换算子-重点" class="headerlink" title="1.3 Transformation转换算子(重点)"></a>1.3 Transformation转换算子(重点)</h2><p><b>RDD整体上分为Value类型、双Value类型和Key-Value类型</b></p><h3 id="1-3-1Value类型"><a href="#1-3-1Value类型" class="headerlink" title="1.3.1Value类型"></a>1.3.1Value类型</h3><h4 id="1-map-映射"><a href="#1-map-映射" class="headerlink" title="1.map()映射"></a>1.map()映射</h4><blockquote><p>函数签名：def map [U:ClassTag]  (f:T=&gt;U):RDD[U]</p></blockquote><p>具体实现</p><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3具体业务逻辑        // 3.1 创建一个RDD        val rdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> sc.makeRDD<span class="token punctuation">(</span>1 to 4,2<span class="token punctuation">)</span>        // 3.2 调用map方法，每个元素乘以2        val mapRdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> rdd.map<span class="token punctuation">(</span>_ * 2<span class="token punctuation">)</span>        // 3.3 打印修改后的RDD中数据        mapRdd.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        //4.关闭连接        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出结果：2 4 6 8</p></blockquote><h4 id="2-mapPartitions-以分区为单位执行Map"><a href="#2-mapPartitions-以分区为单位执行Map" class="headerlink" title="2.mapPartitions()以分区为单位执行Map"></a>2.mapPartitions()以分区为单位执行Map</h4><blockquote><p>函数签名：def mapPartitions[U:ClassTag] (f:leterator[T]=&gt;lterator[U]) </p></blockquote><p>具体实现</p><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3具体业务逻辑        // 3.1 创建一个RDD        val rdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> sc.makeRDD<span class="token punctuation">(</span>1 to 4, 2<span class="token punctuation">)</span>        // 3.2 调用mapPartitions方法，每个元素乘以2        val rdd1 <span class="token operator">=</span> rdd.mapPartitions<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token operator">></span>x.map<span class="token punctuation">(</span>_*2<span class="token punctuation">))</span>        // 3.3 打印修改后的RDD中数据        rdd1.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        //4.关闭连接        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>ps:map()和mapPartitions()区别:map()每次处理一条数据；<br>mapPartitions()每次处理一个分区的数据，当分区内数据处理完原RDD中分区的数据才能释放。<br></b></p><h4 id="3-mapPartitionsWithIndex-带分区号"><a href="#3-mapPartitionsWithIndex-带分区号" class="headerlink" title="3.mapPartitionsWithIndex()带分区号"></a>3.mapPartitionsWithIndex()带分区号</h4><blockquote><p>函数签名：def mapPartitionsWithIndex [U:ClassTag] f:(Int,Iterator[T])=&gt;lterator[U],preservesPartitioning:Boolean = false):RDD[U]</p></blockquote><p>具体实现</p><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3具体业务逻辑        // 3.1 创建一个RDD        val rdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> sc.makeRDD<span class="token punctuation">(</span>1 to 4, 2<span class="token punctuation">)</span>        // 3.2 创建一个RDD，使每个元素跟所在分区号形成一个元组，组成一个新的RDD        val indexRdd <span class="token operator">=</span> rdd.mapPartitionsWithIndex<span class="token punctuation">(</span> <span class="token punctuation">(</span>index,items<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;items.map( (index,_) )&amp;#125; )</span>        //扩展功能：第二个分区元素*2，其余分区不变// 3.3 打印修改后的RDD中数据        indexRdd.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        //4.关闭连接        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-flatMap-压平"><a href="#4-flatMap-压平" class="headerlink" title="4.flatMap()压平"></a>4.flatMap()压平</h4><blockquote><p>函数签名：def flatMap [U:ClassTag] (f:T=&gt;TraversableOnce [U] ):RDD[U]</p></blockquote><p>具体实现</p><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3具体业务逻辑        // 3.1 创建一个RDD        val listRDD<span class="token operator">=</span>sc.makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span>List<span class="token punctuation">(</span>1,2<span class="token punctuation">)</span>,List<span class="token punctuation">(</span>3,4<span class="token punctuation">)</span>,List<span class="token punctuation">(</span>5,6<span class="token punctuation">)</span>,List<span class="token punctuation">(</span>7<span class="token punctuation">))</span>, 2<span class="token punctuation">)</span>        // 3.2 把所有子集合中数据取出放入到一个大的集合中        listRDD.flatMap<span class="token punctuation">(</span>list<span class="token operator">=</span><span class="token operator">></span>list<span class="token punctuation">)</span>.collect.foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>        //4.关闭连接        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-glom-分区转换数组"><a href="#5-glom-分区转换数组" class="headerlink" title="5.glom()分区转换数组"></a>5.glom()分区转换数组</h4><blockquote><p>函数签名：def glom):RDD[Array[T]]</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">        //1.创建SparkConf并设置App名称        val conf <span class="token operator">=</span> new SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span>.setAppName<span class="token punctuation">(</span><span class="token string">"SparkCoreTest"</span><span class="token punctuation">)</span>.setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span>        //2.创建SparkContext，该对象是提交Spark App的入口        val sc <span class="token operator">=</span> new SparkContext<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        //3具体业务逻辑        // 3.1 创建一个RDD        val rdd <span class="token operator">=</span> sc.makeRDD<span class="token punctuation">(</span>1 to 4, 2<span class="token punctuation">)</span>        // 3.2 求出每个分区的最大值  0-<span class="token operator">></span>1,2   1-<span class="token operator">></span>3,4        val maxRdd: RDD<span class="token punctuation">[</span>Int<span class="token punctuation">]</span> <span class="token operator">=</span> rdd.glom<span class="token punctuation">(</span><span class="token punctuation">)</span>.map<span class="token punctuation">(</span>_.max<span class="token punctuation">)</span>        // 3.3 求出所有分区的最大值的和 2 + 4        println<span class="token punctuation">(</span>maxRdd.collect<span class="token punctuation">(</span><span class="token punctuation">)</span>.sum<span class="token punctuation">)</span>        //4.关闭连接        sc.stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot注解大全</title>
      <link href="2021/08/15/springboot-zhu-jie-da-quan/"/>
      <url>2021/08/15/springboot-zhu-jie-da-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="一、annotations（注解）列表"><a href="#一、annotations（注解）列表" class="headerlink" title="一、annotations（注解）列表"></a>一、annotations（注解）列表</h1><p>1、@SpringBootApplication：SpringBootApplication集成了@ComponentScan、@Configuration和@EnableAutoConfiguration</br><br>2、@Configuration 组件</br><br>3、@EnableAutoConfiguration spring实现自动化配置的核心注解</br><br>4、@ComponentScan 组件扫描器</br><br>5、@Component 配合CommandLineRunner使用，在程序启动的时候执行基础任务</br><br>6、@RestController 集成了@Controller和@ResponseBody，表示这是个控制器的bean并以函数的返回值相应到http中，是REST风格的控制器</br><br>7、@Autowired 自动注入</br><br>8、@PathVariable 获取参数</br><br>9、@PathVariable 解决嵌套外链问题</br><br>10、@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用</br></p><h1 id="二、annotations（注解）详解"><a href="#二、annotations（注解）详解" class="headerlink" title="二、annotations（注解）详解"></a>二、annotations（注解）详解</h1><h3 id="No-1"><a href="#No-1" class="headerlink" title="No.1 :"></a>No.1 :</h3><p>@SpringBootApplication：进到源码里可以看到里边组合了三个spring里常见的组件@ComponentScan,@EnableAutoConfiguration,@SpringBootConfiguration</br>首先解析第一个@ComponentScan，在spring框架中有@Service,@Repository,@Component,@Controller用来定义一个bean，而@ComponentScan就是用来自动扫描被这些注解标识的类，最终在IOC中生成对应的bean，在@ComponentScan中定义了三个属性basePackages，includeFilters，excludeFilters用来动态确定扫描范围，默认情况下扫描所有类型，并且扫描范围在@ComponentScan注解所在配置类包及子包的类。<br/>总结一：在使用@SpringBootApplication注解，就说明已经使用了@ComponentScan的默认配置，所以保证所有的bean能够被扫描到，其他类都放在root package的子包里边。<br/><br>再来看第二个@Configuration：这个注解的作用与@SpringBootConfiguration的作用相同都是用来声明当前的类是一个配置类，并会将当前类声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，实例名=方法名，举个栗子：</p><pre class="line-numbers language-bash"><code class="language-bash">@SpringBootApplicationpublic class QuickStartApplication <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>public static void  main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    SpringApplication.run<span class="token punctuation">(</span>QuickStartApplication.class,args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>@Bean //这里声明一个bean的测试类public BeanTest beanTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">return</span>  new BeanTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>------------------------------------------------------@RestControllerpublic class HelloController <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    @Autowired    BeanTest beanTest<span class="token punctuation">;</span> //这里我可以通过注入的方式声明实例@RequestMapping<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hello"</span>,method <span class="token operator">=</span> RequestMethod.GET<span class="token punctuation">)</span>public String hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">return</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>@RequestMapping<span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/beantest"</span>,method <span class="token operator">=</span> RequestMethod.GET<span class="token punctuation">)</span>public String beanTest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token keyword">return</span> <span class="token string">"beanTest!"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后分析@EnableAutoConfiguration：简单概括来说@EnableAutoConfiguration借助@Import的支持，收集和注册特定场景相关bean定义，通过@Import注入了一个ImportSelector的实现类<br>AutoConfigurationImportSelector,这个ImportSelector最终实现根据我们的配置，动态加载所需的bean。<br/></p><h3>小结：</h3>SpringBoot是通过注解@EnableAutoConfiguration的方式，去查找，过滤，加载所需的configuration,@ComponentScan扫描我们自定义的bean,@SpringBootConfiguration使得被@SpringBootApplication注解的类声明为注解类．因此@SpringBootApplication的作用等价于同时组合使用@EnableAutoConfiguration，@ComponentScan，@SpringBootConfiguration<h3 id="No2"><a href="#No2" class="headerlink" title="No2:"></a>No2:</h3><p>@Restcontroller:@Restcontroller相当于@Controller+@ResponseBody合在一起使用，那么问题来了怎么区分使用的规则呢。</br><br>既然说@Rest…是由 @Controller和@ResponseBody结合，那么首先来分析这两位的作用域</br> @Controller的定义是将当前修饰的类注入到IOC容器中，使得程序运行的过程中实例化</br><br>@ResponseBody 的作用概括来说就是指该类所有的API接口返回的数据，不管什么类型，都回以json字符串的形式返回到视图层(view)。</br></p><h3>小结：</h3>如果返回一个单纯的HTML或jsp前端页面(view层)，可以在相应的controller类加入@Controller注解,再稍微深入一点，我想跟随页面返回json格式的数据，则在方法体上加@ResponseBody，而@Restcontroller可以做到@Controller和@ResponseBody的相同的作用，但是@RestC...不能单独与@Controller相提并论。</br><p>未完待续。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python抓取网站图片</title>
      <link href="2020/11/30/python-zhuang-shi-qi/"/>
      <url>2020/11/30/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<p>爬取图片作为爬虫的入门还是很容易就可以实现的，简单的爬虫只需要十几行，这篇我会分为三个部分详细的介绍如何实现，学会可以考虑请博主喝一杯冰阔落哈哈哈。</p><h2 id="1-网页分析"><a href="#1-网页分析" class="headerlink" title="1.网页分析"></a>1.网页分析</h2><h3 id="网页部分"><a href="#网页部分" class="headerlink" title="网页部分"></a>网页部分</h3><p>首先打开的是我经常使用的一个 <a href="http://www.yestone.com/gallery/1501754333627">图片网站</a><br></br><br><img src="https://taogege.xyz/medias/pic_data/11/30_1.png"></br><br>找到其中一个图片在源码的位置，如下<br></br><br><img src="https://taogege.xyz/medias/pic_data/11/30_4.png"><br></br><br>然后可以分析得出图片板块被藏在了class=”vue-waterfall-slot” 的div下边，而我需要的到图片的src,这样就需要更深层的挖掘，打开其中一个图片的div<br></br><br><img src="https://taogege.xyz/medias/pic_data/11/30_2.png"><br></br><br>这样就找到了图片的src</p><h2 id="代码实现和效果呈现"><a href="#代码实现和效果呈现" class="headerlink" title="代码实现和效果呈现"></a>代码实现和效果呈现</h2><p>接下来就是代码的实现，代码很简单具体的我已经在后边做好了注释</p><pre class="line-numbers language-bash"><code class="language-bash">from bs4 <span class="token function">import</span> BeautifulSoupfrom PIL <span class="token function">import</span> Imagefrom io <span class="token function">import</span> BytesIO<span class="token function">import</span> os<span class="token function">import</span> <span class="token function">time</span><span class="token function">import</span> requests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">def url_get <span class="token punctuation">(</span>url<span class="token punctuation">)</span>:    headers <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36"&amp;#125;</span>    r <span class="token operator">=</span> requests.get<span class="token punctuation">(</span>url, headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>    soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>r.content, <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    items <span class="token operator">=</span> soup.find_all<span class="token punctuation">(</span><span class="token string">'div'</span>,class_<span class="token operator">=</span><span class="token string">'vue-waterfall-slot'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#获取HTML里边图片所在的div</span>    folder_path <span class="token operator">=</span> <span class="token string">'./photo'</span> <span class="token comment" spellcheck="true">#图片保存的文件夹</span>    <span class="token keyword">if</span> os.path.exists<span class="token punctuation">(</span>folder_path<span class="token punctuation">)</span> <span class="token operator">==</span> False:       os.makedirs<span class="token punctuation">(</span>folder_path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">    <span class="token keyword">for</span> index, item <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>items<span class="token punctuation">)</span>:<span class="token comment" spellcheck="true">#enumerate是相当于将items里边的数据列举出来进行迭代</span>        <span class="token keyword">if</span> item:            html <span class="token operator">=</span> requests.get<span class="token punctuation">(</span>item.find<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">))</span> <span class="token comment" spellcheck="true">#获取items div 里边的图片src</span>            img_name <span class="token operator">=</span> folder_path + str<span class="token punctuation">(</span>index + 1<span class="token punctuation">)</span> + <span class="token string">'.png'</span> <span class="token comment" spellcheck="true">#设置保存图片的名字</span>            image <span class="token operator">=</span> Image.open<span class="token punctuation">(</span>BytesIO<span class="token punctuation">(</span>html.content<span class="token punctuation">))</span><span class="token comment" spellcheck="true">#用字节流的方式传输</span>            image.save<span class="token punctuation">(</span><span class="token string">'这里是图片保存的路径'</span>+img_name<span class="token punctuation">)</span>            print<span class="token punctuation">(</span><span class="token string">'第%d张图片下载完成'</span> % <span class="token punctuation">(</span>index + 1<span class="token punctuation">))</span>            time.sleep<span class="token punctuation">(</span>1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 自定义延时,防止程序崩掉</span>    print<span class="token punctuation">(</span><span class="token string">'抓取完成'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span><span class="token string">'__main__'</span><span class="token keyword">:</span>    url <span class="token operator">=</span> <span class="token string">"http://www.yestone.com/gallery/1501754333627"</span>    url_get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：</br><img src="https://taogege.xyz/medias/pic_data/11/30_3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/12/hello-world/"/>
      <url>2020/11/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>历时两周终于将个人主页搭建好了，具体详细教程有时间再详细整理整理单独发出来，至于这篇，写过程序的都知道hello world 是什么意思哈哈哈哈，作为留念就不删掉了。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
